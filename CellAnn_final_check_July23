##### CellAnn ####
##### CellAnn final checking !!! #####
#####
##### merge the list table with ######
#####

ssh plyu3@omb2.onc.jhmi.edu
U[9C20&&

#####
#####
setwd("/zp1/data/plyu3/CellAnn_final_check")

check_list <- read.table("reference_table2_final_path.txt",sep="\t",header=T)


check_list$sp = "unknown"

datasheet = read.csv("database_sheet1.csv")

#####
#####

for(i in 1:length(check_list$PMID)){
	tmp = check_list$PMID[i]
	m = match(tmp,datasheet$PMID)
	if(length(m) == 1){
		check_list$sp[i] = datasheet$species[m]
	}
}

#####
#####
#####
#####

library(writexl)
write_xlsx(check_list,path="check_list3.xlsx")



#####
#####
#####
#####


ssh plyu3@omb2.onc.jhmi.edu
U[9C20&&


conda activate seurat4
R
setwd("/zp1/data/plyu3/CellAnn_final_check")

#####
#####


/zp1/data/plyu3/CellAnn_final_check/reference_table2_final_path.txt

#####
#####
#####

check_list <- read.table("reference_table2_final_path.txt",sep="\t",header=T)

colnames(check_list)

#####
##### check each single file #######
#####
colnames(check_list)
"PMID"       "Server"     "Folder"     "TAG"        "seurat_tag"

check_process_Step1 <- function(check_list){
	######
	check_list$seurat_tag = "NotFind!!!"
	######
	for(i in 1:length(check_list$Folder)){
		print(i)
		tmp_folder = check_list$Folder[i]
		######
		setwd(tmp_folder)
		files = list.files()
		index = grep("_seurat_obj_new$",files)
		######
		if(length(index) == 1){
			files_need = files[index]
			files_need_tag = gsub("_seurat_obj_new","",files_need)
			check_list$seurat_tag[i] = files_need_tag
		}
	}
	return(check_list)
}

check_list2 = check_process_Step1(check_list)

######
###### then we write excel to check !!! ######
######

setwd("/zp1/data/plyu3/CellAnn_final_check")
library(writexl)
write_xlsx(check_list2,path="check_list2.xlsx")

######
######
###### Next we will reduce the number of cells for each sample for each cell type !! ########
###### Then we will prepare the python object to check the results !!!! #####################
######
###### See the basic format of the seurat objects ######
######



check_process_Step2 <- function(check_list,list_number=1:439){
	######
	######
	######
	for(i in list_number){
		print(i)
		tmp_folder = check_list$Folder[i]
		print(tmp_folder)
		######
		setwd(tmp_folder)
		files = list.files()
		index = grep("_seurat_obj_new$",files)
		######
		files_need = files[index]
		files_need_tag = gsub("_seurat_obj_new","",files_need)
		######
		tmp_seurat = readRDS(files_need)
		###### count matrix is the count matrix !!!! ###########
		###### count_matrix = tmp_seurat[['RNA']]@counts
		###### head(Matrix::colSums(count_matrix))
		tmp_cells_all = c()
		######
		table_ct = data.frame(table(tmp_seurat$celltype))
		######
		table_ct = table_ct[which(table_ct$Freq > 0),]
		######
		table_ct$Freq_new = 0
		for(j in 1:length(table_ct$Var1)){
			tmp_ct_name = as.character(table_ct$Var1[j])
			tmp_ct_num = table_ct$Freq[j]
			######
			tmp_ct_seurat = tmp_seurat[,which(tmp_seurat$celltype == tmp_ct_name)]
			######
			if(tmp_ct_num > 300){
				#### half half ####
				delta = round(tmp_ct_num - 300)/2
				tmp_ct_seurat_cell_tab = tmp_ct_seurat@meta.data[,c('nCount_RNA','cell_id')]
				tmp_ct_seurat_cell_tab = tmp_ct_seurat_cell_tab[order(tmp_ct_seurat_cell_tab$nCount_RNA),]
				####
				cell_index = tmp_ct_seurat_cell_tab$cell_id[c(delta+1):c(length(tmp_ct_seurat_cell_tab$cell_id)-delta)]
				####
				tmp_ct_seurat_sub = tmp_ct_seurat[,which(tmp_ct_seurat$cell_id %in% cell_index == T)]
				tmp_cells_all = c(tmp_cells_all,tmp_ct_seurat_sub$cell_id)
			}
			if(tmp_ct_num < 301){
				tmp_ct_seurat_sub = tmp_ct_seurat
				tmp_cells_all = c(tmp_cells_all,tmp_ct_seurat_sub$cell_id)
			}
			table_ct$Freq_new[j] = dim(tmp_ct_seurat_sub)[2]
		}
		######
		tmp_seurat_new = tmp_seurat[,which(tmp_seurat$cell_id %in% tmp_cells_all == T)]
		###### new seurat ###
		FN = paste(files_need,'_clean',sep='')
		saveRDS(tmp_seurat_new,file=FN)
		######
		FN2 = paste(files_need,'_cleanstat.txt',sep='')
		write.table(table_ct,file=FN2,sep='\t',row.names=F,quote=F)
	}
	print('Done!!!')
}

check_process_Step2(check_list,list_number=214:439)

#####
##### celltype, dim1, dim2, nCount_RNA #######
#####

#####
##### 如果大于阈值 那么去掉最 小的 counts 和 最大的 counts ###########
##### 不用管 UMAP 了 其实 ########################################
#####


#####
##### Next convert to python format scvi piplines ##############
#####

library(Seurat)
setwd("/zp1/data/plyu3/CellAnn_final_check")
check_list <- read.table("reference_table2_final_path.txt",sep="\t",header=T)

check_process_Step3 <- function(check_list,list_number=1:439){
	######
	######
	######
	for(i in list_number){
		print(i)
		tmp_folder = check_list$Folder[i]
		print(tmp_folder)
		######
		setwd(tmp_folder)
		files = list.files()
		index = grep("_seurat_obj_new_clean$",files)
		######
		files_need = files[index]
		files_need_tag = gsub("_seurat_obj_new_clean","",files_need)
		######
		tmp_seurat = readRDS(files_need)
		###### count matrix is the count matrix !!!! ###########
		library(Seurat)
		write.csv(Matrix::t(tmp_seurat[['RNA']]@counts), file = "py_expression_matrix.csv", row.names = TRUE)
		write.csv(tmp_seurat@meta.data, file = "py_cell_metadata.csv", row.names = TRUE)
		write.csv(rownames(tmp_seurat), file = "py_gene_metadata.csv")
		###### count matrix ####################################
		######
		#####
		###### new seurat ###
		#####
	}
	print('Done!!!')
}


check_process_Step3(check_list,list_number=1:439)

#####
##### let us test in python whether we can read the file !!! #######
#####


ssh plyu3@omb2.onc.jhmi.edu
U[9C20&&


conda activate scvi-env
python

import subprocess
import argparse
import os
import re
import pandas as pd
import scanpy as sc
import scvi
import anndata
import scipy.io as sio
import copy

os.chdir("/zp1/data/plyu3/CellAnn_final_check/Test_datasets")

expression_matrix = anndata.read_mtx("Bladder_example_expression_matrix.mtx")
cell_metadata = pd.read_csv("Bladder_example_cell_metadata.csv", index_col=0)
gene_metadata = pd.read_csv("Bladder_example_gene_metadata.csv", index_col=0)

anndata_obj = copy.deepcopy(expression_matrix)
anndata_obj.obs = cell_metadata
anndata_obj.var['gene_name'] = gene_metadata['x']

######
###### Note that this dataset has the counts already separated in a layer. Here, adata.X contains log transformed scran normalized expression.
######
## red ##
## red ##
## red ##
#sc.pp.normalize_total(anndata_obj, target_sum=1e6)
#sc.pp.log1p(anndata_obj)

#UserWarning: `flavor='seurat_v3'` expects raw count data
anndata_obj.layers["counts"] = anndata_obj.X

#count_mat = anndata_obj.layers["counts"].toarray() 

#anndata_obj.obs["batch"]

####### 

sc.pp.highly_variable_genes(
        anndata_obj,
        flavor="seurat_v3",
        n_top_genes=3000,
        layer="counts",
        batch_key="batch",
        subset=True
) 

#######
scvi.model.SCVI.setup_anndata(anndata_obj, layer="counts", batch_key="batch")
vae = scvi.model.SCVI(anndata_obj, n_layers=2, n_latent=30, gene_likelihood="nb")

vae.train()

corrected_data_vae = vae.get_normalized_expression()

lvae = scvi.model.SCANVI.from_scvi_model(
        vae,
        adata=anndata_obj,
        labels_key="celltype",
        unlabeled_category="Unknown",
)

lvae.train(max_epochs=20, n_samples_per_label=100)


corrected_data_lvae = lvae.get_normalized_expression()


######
######

anndata_obj.obsm["X_scANVI"] = lvae.get_latent_representation(anndata_obj)

###### pip install pymde
from scvi.model.utils import mde

anndata_obj.obsm["X_mde_scanvi"] = mde(anndata_obj.obsm["X_scANVI"])

###### temp save it as the pkl file: ########
######

import pickle

with open("anndata_obj.pkl", "wb") as f:
    pickle.dump(anndata_obj, f)


with open("anndata_obj.pkl", "rb") as f:
    loaded_anndata = pickle.load(f)

import copy

anndata_obj = copy.deepcopy(loaded_anndata)

###### let us plot the figures !!! ########

#width = 16  # Change this value to the desired width in inches
#height = 8  # Change this value to the desired height in inches
#plt.figure(figsize=(width, height))


sc.pl.embedding(
    anndata_obj,
    basis="X_mde_scanvi",
    color="celltype",
    frameon=False,
    save='celltype.png'
)


###### great the class tag is leiden !!! ########



###### Next get new cell clusters !!!! #########
######

sc.pp.neighbors(anndata_obj, use_rep="X_scANVI")
sc.tl.leiden(anndata_obj)


sc.pl.embedding(
    anndata_obj,
    basis="X_mde_scanvi",
    color="leiden",
    frameon=False,
    save='leiden.png'
)



sc.pl.embedding(
    anndata_obj,
    basis="X_mde_scanvi",
    color="_scvi_labels",
    frameon=False,
    save='scvi_labels.png'
)
######
######

anndata_obj_scANVI = pd.DataFrame(anndata_obj.obsm['X_scANVI'])
anndata_obj_scANVI = anndata_obj_scANVI.add_prefix('SCANVI_')
Cellnames = list(pd.DataFrame(anndata_obj.obs['_scvi_batch']).index)

anndata_obj_scANVI['Cell_ID'] = Cellnames
anndata_obj_scANVI.to_csv(file_output, sep="\t",index=False)


anndata_obj_meta = pd.DataFrame(anndata_obj.obs)
file_output = "test_meta.csv"
anndata_obj_meta.to_csv(file_output, sep="\t",index=False)

#####
##### OK!!! Next we will output corrected matrix !!!! ##########
#####

anndata_obj.X.toarray() 
anndata_obj.layers['counts'].toarray() 



#####
##### OK!!! Next we will integrate for the test datasets #######
#####

##### we will integrate from background matrix3 and query data matrix3 !!! #######
#####
##### we need testdatasets to go through the pipline !!! #######
#####
##### see the seurat examples in the old computer #####
#####

##### we will test the example integrate matrix !!! ###
#####
##### 先大概看一下 subset 和 integrate 的 情况 ！！！ #####
#####

##### 先loading以下datasets ！！！ ########
#####

ssh plyu3@omb2.onc.jhmi.edu
U[9C20&&

conda activate seurat4

R

setwd("/zp1/data/plyu3/CellAnn_final_check/Test_datasets")

load("droplet_seurat_merge")

load("facs_seurat_merge")

###### see the meta data ###############

head(droplet_seurat_merge@meta.data)

table(droplet_seurat_merge$tissue)

table(facs_seurat_merge$tissue)

###### extract facs Bladder ############

Bladder_facs_seurat_merge <- facs_seurat_merge[,which(facs_seurat_merge$tissue == "Bladder")]

###### OK!!! count matrix ##############

Bladder_facs_seurat_merge[['RNA']]@counts

droplet_seurat_merge[['RNA']]@counts

######
###### OK!!! let us merge the matrix ####
###### 
batch_list = c("batch_sub","batch_background")

x = Bladder_facs_seurat_merge
y = droplet_seurat_merge

tag = c('Bladder_example_')

Output_py_matrix_test <- function(x,y,batch_list,tag){
	#########
	mat_x = x[['RNA']]@counts
	mat_y = y[['RNA']]@counts
	#########
	overlap_G = rownames(mat_x)[which(rownames(mat_x) %in% rownames(mat_y) == T)]
	#########
	mat_x_cl = mat_x[which(rownames(mat_x) %in% overlap_G == T),]
	mat_y_cl = mat_y[which(rownames(mat_y) %in% overlap_G == T),]
	########
	match_x = match(overlap_G,rownames(mat_x_cl))
	match_y = match(overlap_G,rownames(mat_y_cl))
	#########
	mat_x_cl_s = mat_x_cl[match_x,]
	mat_y_cl_s = mat_y_cl[match_y,]
	##########
	all.equal(rownames(mat_x_cl_s),rownames(mat_y_cl_s))
	########## Next we will add cell meta #####
	cell_meta_x = x@meta.data[,c('tissue','celltype')]
	cell_meta_x$cell_id = rownames(cell_meta_x)
	##########
	cell_meta_y = y@meta.data[,c('tissue','celltype')]
	cell_meta_y$cell_id = rownames(cell_meta_y)
	##########
	cell_meta_x$batch = batch_list[1]
	cell_meta_y$batch = batch_list[2]
	##########
	cell_meta_x$celltype = paste0('sample_',cell_meta_x$celltype)
	cell_meta_y$celltype = paste0('back_',cell_meta_y$celltype)
	##########
	mat_combined = cbind(mat_x_cl_s,mat_y_cl_s)
	cell_meta_combined = rbind(cell_meta_x,cell_meta_y)
	##########
	all.equal(colnames(mat_combined),cell_meta_combined$cell_id)
	##########
	mat_file_name = paste0(tag,"expression_matrix.mtx")
	cell_file_name = paste0(tag,"cell_metadata.csv")
	gene_file_name = paste0(tag,"gene_metadata.csv")
	#########
	library(Seurat)
	library(Matrix)
	writeMM(Matrix::t(mat_combined), file = mat_file_name, row.names = TRUE)
	write.csv(cell_meta_combined, file = cell_file_name, row.names = TRUE)
	write.csv(rownames(mat_combined), file = gene_file_name, row.names = TRUE)
	#########
}

#############
#############

setwd("/zp1/data/plyu3/CellAnn_final_check/Test_datasets")

Output_py_matrix_test(x=Bladder_facs_seurat_merge,y=droplet_seurat_merge,batch_list,tag="Bladder_example_")

#############
############# Next test it in python ############
#############

输出30dim
输出UMAP
输出cluster
输出Matrix

############# set it in python ###################
#############


############# 然后就是 subset reference ###########
#############


















